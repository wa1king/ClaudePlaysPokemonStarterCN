# 宝可梦红版AI代理 - 保存/加载功能开发需求文档

## 1. 核心需求概述

为现有的宝可梦红版AI代理项目添加游戏进度保存和加载功能，确保游戏内存档与AI记忆备份的严格一致性，支持从任意保存点继续游戏。

## 2. 关键设计原则

### 2.1 一致性原则
- **游戏内存档** + **AI记忆备份** 必须同步保存
- 加载时必须同时恢复游戏状态和AI对话历史
- 确保AI能够无缝继续之前的游戏逻辑

### 2.2 MVP原则
- 最小化对现有代码的修改
- 只实现核心的按步数自动保存功能
- 复用现有的代码结构和方法

## 3. 保存功能详细设计

### 3.1 保存触发机制
```python
# 在 run() 方法中，每完成N步后触发
self.total_steps += 1
current_session_steps += 1
if current_session_steps % SAVE_INTERVAL == 0:
    self.auto_save(self.total_steps)

# 异常退出前的紧急保存
try:
    # 主游戏循环
    pass
except (KeyboardInterrupt, Exception) as e:
    logger.info("检测到异常退出，正在保存紧急存档...")
    self.emergency_save()
    raise e
```

**保存触发条件**：
1. **定期保存**：每N步自动保存
2. **紧急保存**：异常退出前自动保存（与定期保存格式完全相同，可正常加载）
3. **手动保存**：用户主动触发（可选扩展）

**重要说明**：紧急保存生成的存档文件与定期保存完全相同，包含相同的数据结构和格式，可以通过所有正常的加载方式进行加载。

### 3.2 保存内容结构
```python
save_data = {
    # 游戏状态 (关键!)
    "pyboy_state": self.emulator.pyboy.save_state(),  # 完整模拟器状态
    
    # AI记忆状态 (关键!) - 基于summarize_history的记忆备份
    "message_history": self.message_history,          # 完整对话历史
    "summary_text": self.extract_current_summary(),   # 当前的summary_text（如果存在）
    
    # 元数据
    "total_steps": self.total_steps,                  # 累计总步数(包含之前存档的步数)
    "save_time": datetime.now().isoformat(),         # 保存时间
    "game_info": self.emulator.get_state_from_memory(), # 游戏信息
    "version": "1.0"
}
```

**记忆备份内容说明**：
记忆备份是指保存 `summarize_history()` 方法生成的 `summary_text` 字段内容。

**核心理解**：
- `summarize_history()` 方法会在对话历史达到60条时触发
- 该方法使用 `SUMMARY_PROMPT` 生成一个游戏进度总结（`summary_text`）
- 这个 `summary_text` 就是我们需要备份的"临时记忆"

**summary_text 内容要求**：
严格按照 `SUMMARY_PROMPT` 的要求，包含以下5个方面：
1. 你达到的关键游戏事件和里程碑
2. 你做出的重要决定
3. 你当前正在处理的目标或任务
4. 你当前的位置和宝可梦队伍状态
5. 你提到的任何策略或计划

**备份策略**：
- 保存时：提取当前的 `summary_text`（如果存在）
- 加载时：恢复 `summary_text` 并重建相应的 `message_history` 结构
- 确保AI能够基于这个总结无缝继续游戏

**重要说明**：
- `pyboy.save_state()` 保存的是**完整的模拟器状态**，包括所有RAM、寄存器、游戏数据
- 这是**即时存档**，不依赖游戏内的存档系统
- 加载时会完全恢复到保存时的状态，无需游戏内存档操作
- 可以在游戏的任何时刻进行保存/加载

### 3.3 文件命名和管理规范

#### 3.3.1 单一存档文件（包含步数信息）
```python
# 使用包含步数的存档文件名，但仍然是单一存档概念
def get_save_filename(self, total_steps):
    """获取存档文件名，包含总步数信息"""
    return os.path.join(self.save_dir, f"pokemon_save_step{total_steps:04d}.pkl")

def get_backup_filename(self, total_steps):
    """获取备份文件名"""
    return os.path.join(self.save_dir, f"pokemon_save_step{total_steps:04d}_backup.pkl")

def find_latest_save(self):
    """查找最新的存档文件"""
    if not os.path.exists(self.save_dir):
        return None
    
    save_files = []
    for filename in os.listdir(self.save_dir):
        if filename.startswith("pokemon_save_step") and filename.endswith(".pkl") and "backup" not in filename:
            # 提取步数
            try:
                step_str = filename.replace("pokemon_save_step", "").replace(".pkl", "")
                steps = int(step_str)
                save_files.append((steps, filename))
            except ValueError:
                continue
    
    if save_files:
        # 返回步数最大的存档文件
        latest_steps, latest_filename = max(save_files, key=lambda x: x[0])
        return os.path.join(self.save_dir, latest_filename), latest_steps
    
    return None, 0
```

#### 3.3.2 存档备份和覆盖策略
```python
def save_with_backup(self, save_data, total_steps):
    """
    安全保存策略：删除旧存档，保存新存档，保留备份
    """
    # 查找并删除旧的存档文件（保持单一存档概念）
    old_save_path, old_steps = self.find_latest_save()
    if old_save_path and os.path.exists(old_save_path):
        # 将旧存档重命名为备份
        backup_path = self.get_backup_filename(old_steps)
        shutil.move(old_save_path, backup_path)
        logger.info(f"旧存档已备份到: {backup_path}")
    
    # 保存新存档
    new_save_path = self.get_save_filename(total_steps)
    with open(new_save_path, 'wb') as f:
        pickle.dump(save_data, f)
    
    logger.info(f"新存档已保存到: {new_save_path}")

def emergency_save(self):
    """
    紧急保存方法：在异常退出前保存当前状态
    生成的存档文件与正常保存完全相同，可以正常加载
    """
    logger.info("执行紧急保存...")
    save_data = {
        "pyboy_state": self.emulator.pyboy.save_state(),
        "message_history": self.message_history,
        "summary_text": self.extract_current_summary(),
        "total_steps": self.total_steps,
        "save_time": datetime.now().isoformat(),
        "game_info": self.emulator.get_state_from_memory(),
        "version": "1.0"
    }
    
    # 使用与正常保存相同的保存策略
    self.save_with_backup(save_data, self.total_steps)
    logger.info("紧急保存完成")
```

**存档管理策略**：
- **单一存档概念**：同时只存在一个主存档文件
- **文件名包含步数**：便于识别游戏进度
- **自动备份**：保存新存档时，旧存档自动变为备份
- **步数连续性**：文件名直观显示累计步数

## 4. 加载功能详细设计

### 4.1 简化的加载流程
```python
def load_complete_state(self, filename):
    # 1. 读取保存文件
    with open(filename, 'rb') as f:
        save_data = pickle.load(f)
    
    # 2. 恢复游戏状态
    self.emulator.pyboy.load_state(save_data["pyboy_state"])
    
    # 3. 恢复AI记忆状态 - 简化逻辑
    if "summary_text" in save_data and save_data["summary_text"]:
        # 有摘要文本，重建摘要格式的message_history
        self.restore_summary_to_history(save_data["summary_text"])
    else:
        # 没有摘要文本，直接使用原始message_history
        self.message_history = save_data["message_history"]
    
    # 4. 恢复步数计数
    self.total_steps = save_data.get("total_steps", 0)
    
    # 5. 日志记录
    logger.info(f"已加载保存点: {filename} (第{self.total_steps}步)")
```

**简化的核心思路**：
1. **保存什么就恢复什么**：不需要复杂的转换逻辑
2. **优先使用摘要**：如果存档中有 `summary_text`，就用它重建摘要格式
3. **降级到完整历史**：如果没有摘要，就直接使用完整的 `message_history`
4. **保持一致性**：确保恢复后的格式与正常运行时一致

### 4.2 兼容现有加载逻辑
- 扩展现有的 `load_state` 参数处理
- 保持向后兼容性
- 自动检测保存文件格式

## 5. 代码修改计划

### 5.1 需要修改的文件

#### config.py
```python
# 新增配置项
AUTO_SAVE_ENABLED = True
SAVE_INTERVAL_STEPS = 10
SAVE_DIRECTORY = "./saves"
```

#### main.py
```python
# 新增命令行参数
--save-every N      # 每N步保存（默认10）
--save-dir PATH     # 保存目录（默认./saves）
--no-auto-save      # 禁用自动保存
--new-game          # 强制从头开始新游戏，覆盖现有存档
--load-backup       # 从备份存档恢复（用于存档损坏时）
--save-info         # 显示当前存档信息
```

**默认加载逻辑**：
```python
def determine_load_state(args, agent):
    """确定要加载的存档文件"""
    if args.new_game:
        return None, 0  # 强制新游戏
    elif args.load_backup:
        # 从备份存档加载 - 需要先找到最新的备份
        if not os.path.exists(args.save_dir):
            logger.error("保存目录不存在")
            return None, 0
        
        backup_files = []
        for filename in os.listdir(args.save_dir):
            if filename.startswith("pokemon_save_step") and filename.endswith("_backup.pkl"):
                try:
                    step_str = filename.replace("pokemon_save_step", "").replace("_backup.pkl", "")
                    steps = int(step_str)
                    backup_files.append((steps, filename))
                except ValueError:
                    continue
        
        if backup_files:
            latest_steps, latest_backup = max(backup_files, key=lambda x: x[0])
            backup_path = os.path.join(args.save_dir, latest_backup)
            return backup_path, latest_steps
        else:
            logger.error("没有找到备份存档")
            return None, 0
    else:
        # 默认行为：查找最新的主存档
        latest_save_path, latest_steps = agent.find_latest_save()
        if latest_save_path:
            return latest_save_path, latest_steps
        return None, 0  # 没有存档，开始新游戏
```

#### agent/simple_agent.py
```python
# 新增方法
def auto_save(self, total_steps)
def emergency_save(self)  # 异常退出前的紧急保存
def save_complete_state(self, filename, total_steps)
def load_complete_state(self, save_data)
def get_save_filename(self, total_steps)  # 获取存档文件名（包含步数）
def get_backup_filename(self, total_steps)  # 获取备份文件名
def find_latest_save(self)  # 查找最新的存档文件
def save_with_backup(self, save_data, total_steps)  # 安全保存策略
def extract_current_summary(self)  # 提取当前的summary_text
def restore_summary_to_history(self, summary_text, screenshot_b64=None)  # 基于summary_text重建message_history

# 修改现有方法
__init__()  # 添加保存相关初始化，包括total_steps计数器
run()       # 添加自动保存调用，使用累计步数
```

### 5.2 记忆备份方法实现

#### 简化的记忆备份方法
```python
def extract_current_summary(self):
    """
    提取当前的summary_text
    简单方法：如果对话历史已经被总结过，直接从message_history中提取
    """
    # 如果message_history只有一条消息且包含摘要标识，说明已经被总结过
    if (len(self.message_history) == 1 and 
        self.message_history[0]["role"] == "user"):
        
        content = self.message_history[0]["content"]
        if isinstance(content, list) and len(content) > 0:
            first_text = content[0].get("text", "")
            if "对话历史摘要" in first_text:
                # 提取冒号后的摘要内容
                if ": " in first_text:
                    return first_text.split(": ", 1)[1]
    
    return None  # 没有摘要时返回None

def restore_summary_to_history(self, summary_text):
    """
    基于保存的summary_text重建message_history
    直接调用现有的summarize_history逻辑，但使用保存的摘要文本
    """
    # 获取当前截图
    screenshot = self.emulator.get_screenshot()
    screenshot_b64 = get_screenshot_base64(screenshot, upscale=2)
    
    # 直接构建与summarize_history相同的message_history结构
    self.message_history = [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": f"对话历史摘要 (代表之前的 {self.max_history} 条消息): {summary_text}"
                },
                {
                    "type": "text",
                    "text": "\n\n当前游戏截图供参考:"
                },
                {
                    "type": "image",
                    "source": {
                        "type": "base64",
                        "media_type": "image/png",
                        "data": screenshot_b64,
                    },
                },
                {
                    "type": "text",
                    "text": "你刚刚被要求总结到目前为止的游戏过程，这就是你在上面看到的摘要。你现在可以通过选择下一个动作来继续游戏。"
                },
            ]
        }
    ]
```

**简化说明**：
- **保存时**：只需要保存 `message_history` 和提取的 `summary_text`
- **加载时**：如果有 `summary_text`，直接用它重建标准的摘要格式；如果没有，直接使用完整的 `message_history`
- **核心思路**：复用现有的 `summarize_history` 输出格式，避免复杂的解析和重建逻辑

### 5.3 最小修改策略

#### SimpleAgent.__init__() 修改
```python
# 只添加必要的初始化参数
def __init__(self, ..., save_interval=10, save_dir="./saves", auto_save_enabled=True):
    # 现有代码保持不变
    # 只在末尾添加保存相关初始化
    self.save_interval = save_interval
    self.save_dir = save_dir
    self.auto_save_enabled = auto_save_enabled
    self.total_steps = 0
```

#### SimpleAgent.run() 修改
```python
# 主循环添加异常处理和紧急保存
try:
    while self.running and steps_completed < num_steps:
        # 现有的游戏循环逻辑
        self.total_steps += 1
        current_session_steps += 1
        logger.info(f"完成第{current_session_steps}/{num_steps}步 (累计第{self.total_steps}步)")
        
        # 自动保存检查
        if self.auto_save_enabled and current_session_steps % self.save_interval == 0:
            self.auto_save(self.total_steps)
        
        steps_completed += 1

except (KeyboardInterrupt, Exception) as e:
    logger.info("检测到异常退出，正在保存紧急存档...")
    if self.auto_save_enabled:
        self.emergency_save()
    raise e
```

## 6. 使用场景示例

### 6.1 默认行为（从最新存档继续）
```bash
python main.py --steps 50
# 默认行为：
# 1. 自动查找最新的 pokemon_save_stepXXXX.pkl 文件
# 2. 如果不存在存档，从头开始新游戏
# 3. 每10步自动保存，异常退出前紧急保存
# 4. 文件名示例：pokemon_save_step1050.pkl（表示累计1050步）
```

### 6.2 强制从头开始新游戏
```bash
python main.py --steps 50 --new-game
# 忽略现有存档，强制从头开始新游戏
# 会创建新的存档文件，如：pokemon_save_step0050.pkl
```

### 6.3 从备份存档恢复
```bash
python main.py --load-backup --steps 20
# 从最新的备份存档恢复游戏
# 备份文件示例：pokemon_save_step1000_backup.pkl
```

### 6.4 自定义保存设置
```bash
python main.py --steps 100 --save-every 5 --save-dir "./my_saves"
# 每5步保存到指定目录
# 仍然使用包含步数的文件名格式
```

### 6.5 查看存档信息
```bash
python main.py --save-info
# 显示当前最新存档的详细信息
# 包括：文件名、累计步数、保存时间、游戏进度等
```

## 7. 技术实现细节

### 7.1 保存时机的精确控制
- 在每个step完成后立即检查
- 确保保存时游戏状态稳定
- 避免在游戏状态变化过程中保存

### 7.2 文件管理
```python
# 自动创建保存目录
os.makedirs(self.save_dir, exist_ok=True)

# 保存文件完整路径
save_path = os.path.join(self.save_dir, filename)
```

### 7.3 错误处理
```python
try:
    self.save_complete_state(filename, steps_completed)
    logger.info(f"[保存] 成功保存到: {filename}")
except Exception as e:
    logger.error(f"[保存] 保存失败: {e}")
    # 继续游戏，不中断
```

## 8. 验收标准

### 8.1 功能验证
- [ ] 每10步能够自动保存到固定存档文件
- [ ] 异常退出前能够自动保存
- [ ] 紧急保存的存档可以被正常加载和识别
- [ ] 默认从存档继续游戏
- [ ] 保存前自动备份上一个存档
- [ ] 保存文件包含游戏状态和AI记忆
- [ ] 从存档加载后AI能继续之前的逻辑
- [ ] 存档包含累计步数信息
- [ ] 游戏内存档与AI记忆完全同步
- [ ] --new-game 参数能强制开始新游戏
- [ ] --load-backup 能从备份存档恢复
- [ ] --save-info 能显示存档详细信息
- [ ] 紧急保存和正常保存的存档格式完全一致

### 8.2 代码质量
- [ ] 对现有代码修改最小
- [ ] 新增代码遵循现有风格
- [ ] 完善的错误处理和日志
- [ ] 保持向后兼容性

## 9. 开发优先级

### Phase 1: 核心功能
1. 实现基本的保存/加载方法
2. 添加自动保存触发逻辑
3. 实现文件命名规范

### Phase 2: 集成测试
1. 测试保存/加载的一致性
2. 验证AI记忆的连续性
3. 测试各种游戏状态下的保存

### Phase 3: 优化完善
1. 添加命令行参数
2. 完善错误处理
3. 添加详细日志

## 10. 后续扩展可能性

### 10.1 高级功能（非MVP范围）
- 智能保存点检测（重要事件触发）
- 保存文件自动清理和管理
- 保存点预览和比较功能
- 压缩保存文件以节省空间

### 10.2 用户体验优化
- 保存进度显示
- 快速加载最近保存点
- 保存点备注和标签功能

---

**文档版本**: v1.0  
**创建时间**: 2024年1月15日  
**最后更新**: 2024年1月15日